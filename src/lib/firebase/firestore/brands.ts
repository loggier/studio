// src/lib/firebase/firestore/brands.ts
import {
  collection,
  addDoc,
  getDocs,
  deleteDoc,
  doc,
  updateDoc, // Import updateDoc
  query,
  orderBy,
  Timestamp, // Import Timestamp if you use date fields
  serverTimestamp, // Use serverTimestamp for consistency
  where, // Import where for checking models
  limit // Import limit for efficiency
} from 'firebase/firestore';
import { db } from '@/lib/firebase/config'; // Adjust path as needed
import { checkModelsExistForBrand } from './models'; // Import the check function

// Define the structure of a Brand in Firestore
// Add any other fields you might need, like createdAt, updatedAt
export interface Brand {
  id: string; // Firestore document ID
  name: string;
  createdAt?: Timestamp; // Optional: Timestamp for creation date
  updatedAt?: Timestamp; // Optional: Timestamp for last update
}

// Define the structure for adding a new brand (ID is generated by Firestore)
export interface NewBrandData {
  name: string;
}

const brandsCollectionRef = collection(db, 'brands');

/**
 * Fetches all brands from Firestore, ordered by name.
 * @returns A promise that resolves to an array of Brand objects.
 */
export async function fetchBrands(): Promise<Brand[]> {
  try {
    const q = query(brandsCollectionRef, orderBy('name')); // Order by name alphabetically
    const querySnapshot = await getDocs(q);
    const brands = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    } as Brand));
    // Convert Timestamps to Dates if needed for display, or handle in component
    return brands;
  } catch (error) {
    console.error('Error fetching brands: ', error);
    throw new Error('Failed to fetch brands from Firestore.');
  }
}

/**
 * Adds a new brand to the Firestore 'brands' collection.
 * @param newBrandData - An object containing the brand name.
 * @returns A promise that resolves to the newly created Brand object (with ID).
 */
export async function addBrand(newBrandData: NewBrandData): Promise<Brand> {
  try {
    // Ensure name is trimmed and potentially handle case sensitivity if needed
    const name = newBrandData.name.trim();
    if (!name) throw new Error("Brand name cannot be empty.");

    // Optional: Add check for duplicate brand name before adding
    // const checkQuery = query(brandsCollectionRef, where("name", "==", name), limit(1));
    // const checkSnapshot = await getDocs(checkQuery);
    // if (!checkSnapshot.empty) {
    //   throw new Error(`Brand with name "${name}" already exists.`);
    // }

    const docData = {
      name: name,
      createdAt: serverTimestamp(), // Use server timestamp for creation
      updatedAt: serverTimestamp(), // Also set updatedAt on creation
    };

    const docRef = await addDoc(brandsCollectionRef, docData);

    // Construct the return object immediately (Firestore Timestamps might be pending)
    // For accurate timestamps immediately, you'd need to fetch the doc again,
    // but this is usually sufficient for UI updates.
    return { id: docRef.id, name: name }; // Return without timestamps for simplicity here

  } catch (error) {
    console.error('Error adding brand: ', error);
    throw new Error(`Failed to add brand: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Updates an existing brand in the Firestore 'brands' collection.
 * @param brandId - The ID of the brand document to update.
 * @param newName - The new name for the brand.
 * @returns A promise that resolves when the update is complete.
 */
export async function updateBrand(brandId: string, newName: string): Promise<void> {
  try {
    const name = newName.trim();
    if (!name) throw new Error("Brand name cannot be empty.");

    // Optional: Add check for duplicate brand name before updating
    // const checkQuery = query(brandsCollectionRef, where("name", "==", name), limit(1));
    // const checkSnapshot = await getDocs(checkQuery);
    // if (!checkSnapshot.empty && checkSnapshot.docs[0].id !== brandId) {
    //   throw new Error(`Another brand with name "${name}" already exists.`);
    // }

    const brandDocRef = doc(db, 'brands', brandId);
    await updateDoc(brandDocRef, {
      name: name,
      updatedAt: serverTimestamp(), // Update the timestamp on modification
    });
  } catch (error) {
    console.error('Error updating brand: ', error);
    throw new Error(`Failed to update brand: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Deletes a brand from the Firestore 'brands' collection after checking for associated models.
 * @param brandId - The ID of the brand document to delete.
 * @returns A promise that resolves when the deletion is complete.
 * @throws Error if the brand is associated with existing models.
 */
export async function deleteBrand(brandId: string): Promise<void> {
  try {
    // Check if any models are using this brand
    const modelsExist = await checkModelsExistForBrand(brandId);
    if (modelsExist) {
      throw new Error(`No se puede eliminar la marca porque está asociada a uno o más modelos.`);
    }

    const brandDocRef = doc(db, 'brands', brandId);
    await deleteDoc(brandDocRef);
  } catch (error) {
    console.error('Error deleting brand: ', error);
    // Re-throw the specific error or a generic one
    if (error instanceof Error && error.message.startsWith('No se puede eliminar la marca')) {
        throw error;
    }
    throw new Error('Failed to delete brand from Firestore.');
  }
}