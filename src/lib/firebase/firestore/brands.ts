// src/lib/firebase/firestore/brands.ts
import {
  collection,
  addDoc,
  getDocs,
  deleteDoc,
  doc,
  query,
  orderBy,
  Timestamp, // Import Timestamp if you use date fields
} from 'firebase/firestore';
import { db } from '@/lib/firebase/config'; // Adjust path as needed

// Define the structure of a Brand in Firestore
// Add any other fields you might need, like createdAt
export interface Brand {
  id: string; // Firestore document ID
  name: string;
  createdAt?: Timestamp; // Optional: Timestamp for creation date
}

// Define the structure for adding a new brand (ID is generated by Firestore)
export interface NewBrandData {
  name: string;
}

const brandsCollectionRef = collection(db, 'brands');

/**
 * Fetches all brands from Firestore, ordered by name.
 * @returns A promise that resolves to an array of Brand objects.
 */
export async function fetchBrands(): Promise<Brand[]> {
  try {
    const q = query(brandsCollectionRef, orderBy('name')); // Order by name alphabetically
    const querySnapshot = await getDocs(q);
    const brands = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    } as Brand));
    return brands;
  } catch (error) {
    console.error('Error fetching brands: ', error);
    throw new Error('Failed to fetch brands from Firestore.');
  }
}

/**
 * Adds a new brand to the Firestore 'brands' collection.
 * @param newBrandData - An object containing the brand name.
 * @returns A promise that resolves to the newly created Brand object (with ID).
 */
export async function addBrand(newBrandData: NewBrandData): Promise<Brand> {
  try {
    const docRef = await addDoc(brandsCollectionRef, {
      ...newBrandData,
      createdAt: Timestamp.now(), // Add a timestamp if needed
    });
    // Fetch the newly added document to return the complete object
    // This is optional, you could also just construct the object locally
    // const newDocSnap = await getDoc(docRef);
    // if (!newDocSnap.exists()) {
    //   throw new Error("Failed to retrieve newly added brand.");
    // }
    // return { id: newDocSnap.id, ...newDocSnap.data() } as Brand;

    // Or simply construct it:
    return { id: docRef.id, ...newBrandData, createdAt: Timestamp.now() };

  } catch (error) {
    console.error('Error adding brand: ', error);
    throw new Error('Failed to add brand to Firestore.');
  }
}

/**
 * Deletes a brand from the Firestore 'brands' collection.
 * @param brandId - The ID of the brand document to delete.
 * @returns A promise that resolves when the deletion is complete.
 */
export async function deleteBrand(brandId: string): Promise<void> {
  try {
    const brandDocRef = doc(db, 'brands', brandId);
    await deleteDoc(brandDocRef);
  } catch (error) {
    console.error('Error deleting brand: ', error);
    // Consider specific error handling, e.g., if the brand is linked to models
    throw new Error('Failed to delete brand from Firestore.');
  }
}
