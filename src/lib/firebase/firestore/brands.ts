// src/lib/firebase/firestore/brands.ts
import {
  collection,
  addDoc,
  getDocs,
  deleteDoc,
  doc,
  updateDoc, // Import updateDoc
  query,
  orderBy,
  Timestamp, // Import Timestamp if you use date fields
  serverTimestamp // Use serverTimestamp for consistency
} from 'firebase/firestore';
import { db } from '@/lib/firebase/config'; // Adjust path as needed

// Define the structure of a Brand in Firestore
// Add any other fields you might need, like createdAt, updatedAt
export interface Brand {
  id: string; // Firestore document ID
  name: string;
  createdAt?: Timestamp; // Optional: Timestamp for creation date
  updatedAt?: Timestamp; // Optional: Timestamp for last update
}

// Define the structure for adding a new brand (ID is generated by Firestore)
export interface NewBrandData {
  name: string;
}

const brandsCollectionRef = collection(db, 'brands');

/**
 * Fetches all brands from Firestore, ordered by name.
 * @returns A promise that resolves to an array of Brand objects.
 */
export async function fetchBrands(): Promise<Brand[]> {
  try {
    const q = query(brandsCollectionRef, orderBy('name')); // Order by name alphabetically
    const querySnapshot = await getDocs(q);
    const brands = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    } as Brand));
    // Convert Timestamps to Dates if needed for display, or handle in component
    return brands;
  } catch (error) {
    console.error('Error fetching brands: ', error);
    throw new Error('Failed to fetch brands from Firestore.');
  }
}

/**
 * Adds a new brand to the Firestore 'brands' collection.
 * @param newBrandData - An object containing the brand name.
 * @returns A promise that resolves to the newly created Brand object (with ID).
 */
export async function addBrand(newBrandData: NewBrandData): Promise<Brand> {
  try {
    // Ensure name is trimmed and potentially handle case sensitivity if needed
    const name = newBrandData.name.trim();
    if (!name) throw new Error("Brand name cannot be empty.");

    const docData = {
      name: name,
      createdAt: serverTimestamp(), // Use server timestamp for creation
      updatedAt: serverTimestamp(), // Also set updatedAt on creation
    };

    const docRef = await addDoc(brandsCollectionRef, docData);

    // Construct the return object immediately (Firestore Timestamps might be pending)
    // For accurate timestamps immediately, you'd need to fetch the doc again,
    // but this is usually sufficient for UI updates.
    return { id: docRef.id, name: name }; // Return without timestamps for simplicity here

  } catch (error) {
    console.error('Error adding brand: ', error);
    throw new Error('Failed to add brand to Firestore.');
  }
}

/**
 * Updates an existing brand in the Firestore 'brands' collection.
 * @param brandId - The ID of the brand document to update.
 * @param newName - The new name for the brand.
 * @returns A promise that resolves when the update is complete.
 */
export async function updateBrand(brandId: string, newName: string): Promise<void> {
  try {
    const name = newName.trim();
    if (!name) throw new Error("Brand name cannot be empty.");

    const brandDocRef = doc(db, 'brands', brandId);
    await updateDoc(brandDocRef, {
      name: name,
      updatedAt: serverTimestamp(), // Update the timestamp on modification
    });
  } catch (error) {
    console.error('Error updating brand: ', error);
    throw new Error('Failed to update brand in Firestore.');
  }
}

/**
 * Deletes a brand from the Firestore 'brands' collection.
 * NOTE: Consider adding checks if the brand is associated with models before deletion.
 * @param brandId - The ID of the brand document to delete.
 * @returns A promise that resolves when the deletion is complete.
 */
export async function deleteBrand(brandId: string): Promise<void> {
  try {
    // TODO: Add logic here to check if the brand is used by any models.
    // If it is, prevent deletion or ask for confirmation.
    // Example:
    // const modelsUsingBrand = await checkModelsForBrand(brandId);
    // if (modelsUsingBrand.length > 0) {
    //   throw new Error(`Cannot delete brand. It is used by ${modelsUsingBrand.length} model(s).`);
    // }

    const brandDocRef = doc(db, 'brands', brandId);
    await deleteDoc(brandDocRef);
  } catch (error) {
    console.error('Error deleting brand: ', error);
    // Provide more specific error message if possible
    if (error instanceof Error && error.message.startsWith('Cannot delete brand')) {
        throw error;
    }
    throw new Error('Failed to delete brand from Firestore.');
  }
}
